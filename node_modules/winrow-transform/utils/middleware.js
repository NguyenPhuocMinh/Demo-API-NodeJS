'use strict';

const winrow = require('winrow');
const {
  Promise,
  lodash,
  returnCodes,
  getRequestId,
  jwt
} = winrow;
const loggingFactory = require('winrow-logger');
const errorCodes = require('./errorCodes');
const transformText = require('./transformText');
const {
  get,
  isEmpty,
  isFunction,
  isArray,
} = lodash;
const { name } = require('../package.json');
const nameLib = name;
const dataSecret = require('../utils/secret');

const middleware = (req, res, input, output, serviceMethod) => {
  const requestId = getRequestId();
  let argsInput = {};
  let argsOutput = {};
  const opts = {
    loggingFactory: loggingFactory,
    requestId: requestId
  };

  if (input) {
    if (isFunction(input.transform)) {
      argsInput = input.transform(req);
    }
  }

  return Promise.resolve(argsInput)
    .then(args => {
      return serviceMethod(args, opts);
    })
    .then(result => {
      if (output) {
        if (isFunction(output.transform)) {
          argsOutput = output.transform = output.transform(result);
        }
        argsOutput = output.transform;
      }
      return argsOutput;
    })
    .then(data => {
      const token = get(data, 'body.token');
      if (!isEmpty(token)) {
        res.cookie('X-AccessToken', token, {
          maxAge: dataSecret.tokenLife,
          httpOnly: true
        })
      }
      const headers = get(data, 'headers');
      const body = get(data, 'body');
      const decodedToken = jwt.verify(token, dataSecret.secret);
      if (!isEmpty(decodedToken)) {
        if (!isEmpty(headers) && !isEmpty(body)) {
          return res
            .set(headers)
            .send(body)
        }
        if (isEmpty(headers) && !isEmpty(body)) {
          return res.send(body)
        }
      }
    })
    .catch(error => {
      loggingFactory.error(`Middleware has error : ${JSON.stringify(error, null, 1)}`, {
        labelName: `[${nameLib}]`,
        requestId: `${requestId}`
      })
      if (error instanceof Error) {
        const errorMessage = returnCodes(errorCodes, error.message);
        const statusCode = get(errorMessage, 'statusCode');
        return res.status(statusCode).send(errorMessage);
      }
      if (isArray(error)) {
        error = error.map(err => {
          const lastElement = err.split(' ').slice(-1).pop();
          const transferErr = transformText(lastElement);
          const messageError = `[${toUpper(err.split(' ')[0])}]-${transferErr}`;
          return messageError;
        })
        return res.status(500).send(error);
      }
      const { name, message, statusCode } = error;
      if (statusCode) {
        return res.status(statusCode).send({ name: name, message: message });
      }
    })
};

module.exports = middleware;