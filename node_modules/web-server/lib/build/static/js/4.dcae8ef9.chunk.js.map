{"version":3,"sources":["dataProvider/addUploadFeature.js","dataProvider/rest.js"],"names":["convertFileToBase64","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsDataURL","rawFile","uploadCapableDataProvider","dataProvider","update","resource","params","data","thumbnail","newThumbnail","formerThumbnail","then","base64Thumbnail","src","transformedNewThumbnail","catch","err","thumbnailFile","addUploadFeature","jsonServerProvider","process","url","options","headers","Headers","Accept","set","localStorage","getItem","fetchUtils","fetchJson","delayedDataProvider","Proxy","get","target","name","self","setTimeout"],"mappings":"6IAmEMA,EAAsB,SAAAC,GAC1B,OAAO,IAAIC,SAAQ,SAACC,EAASC,GAC3B,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,kBAAMJ,EAAQE,EAAOG,SACrCH,EAAOI,QAAUL,EAEjBC,EAAOK,cAAcT,EAAKU,aC1DxBC,EDVwB,SAAAC,GAAY,kCACrCA,GADqC,IAExCC,OAAQ,SAACC,EAAUC,GACjB,GAAiB,aAAbD,IAA4BC,EAAOC,KAAKC,UAC1C,OAAOL,EAAaC,OAAOC,EAAUC,GAEvC,IAAME,EAAYF,EAAOC,KAAKC,UACxBC,EAAeD,EACfE,GAAmBF,EACzB,MAA4B,kBAAjBC,EACFjB,QAAQC,QAAQgB,GACpBE,MAAK,SAAAC,GACJ,MAAO,CACLC,IAAKD,MAGRD,MAAK,SAAAG,GACJ,OAAOX,EAAaC,OAAOC,EAApB,2BACFC,GADE,IAELC,KAAK,2BACAD,EAAOC,MADR,IAEFC,UAAU,2BACLM,GACAJ,WAKVK,OAAM,SAAAC,GACL,OAAOxB,QAAQE,OAAOsB,MAGrBxB,QAAQC,QAAQgB,GACpBE,MAAK,SAAAM,GAAa,OAAI3B,EAAoB2B,MAC1CN,MAAK,SAAAC,GACJ,MAAO,CACLC,IAAKD,MAGRD,MAAK,SAAAG,GACJ,OAAOX,EAAaC,OAAOC,EAApB,2BACFC,GADE,IAELC,KAAK,2BACAD,EAAOC,MADR,IAEFC,UAAU,2BACLM,GACAJ,WAKVK,OAAM,SAAAC,GACL,OAAOxB,QAAQE,OAAOsB,SC1CIE,CADbC,YAVJC,kCAEE,SAACC,GAAuB,IAAlBC,EAAiB,uDAAP,GAKjC,OAJKA,EAAQC,UACXD,EAAQC,QAAU,IAAIC,QAAQ,CAAEC,OAAQ,sBAE1CH,EAAQC,QAAQG,IAAI,iBAAkBC,aAAaC,QAAQ,UACpDC,IAAWC,UAAUT,EAAKC,OAM7BS,EAAsB,IAAIC,MAAM9B,EAA2B,CAC/D+B,IAAK,SAACC,EAAQC,EAAMC,GAAf,MACM,SAATD,EACIC,EACA,SAAC/B,EAAUC,GAAX,OACA,IAAId,SAAQ,SAAAC,GAAO,OACjB4C,YACE,kBAAM5C,EAAQS,EAA0BiC,GAAM9B,EAAUC,MACxD,YAKGyB","file":"static/js/4.dcae8ef9.chunk.js","sourcesContent":["/**\n * For posts update only, convert uploaded image in base 64 and attach it to\n * the `picture` sent property, with `src` and `title` attributes.\n */\n\nconst addUploadCapabilities = dataProvider => ({\n  ...dataProvider,\n  update: (resource, params) => {\n    if (resource !== 'accounts' || !params.data.thumbnail) {\n      return dataProvider.update(resource, params);\n    }\n    const thumbnail = params.data.thumbnail;\n    const newThumbnail = thumbnail;\n    const formerThumbnail = !thumbnail;\n    if (typeof newThumbnail === 'string') {\n      return Promise.resolve(newThumbnail)\n        .then(base64Thumbnail => {\n          return {\n            src: base64Thumbnail\n          }\n        })\n        .then(transformedNewThumbnail => {\n          return dataProvider.update(resource, {\n            ...params,\n            data: {\n              ...params.data,\n              thumbnail: {\n                ...transformedNewThumbnail,\n                ...formerThumbnail\n              }\n            }\n          })\n        })\n        .catch(err => {\n          return Promise.reject(err);\n        })\n    }\n    return Promise.resolve(newThumbnail)\n      .then(thumbnailFile => convertFileToBase64(thumbnailFile))\n      .then(base64Thumbnail => {\n        return {\n          src: base64Thumbnail\n        }\n      })\n      .then(transformedNewThumbnail => {\n        return dataProvider.update(resource, {\n          ...params,\n          data: {\n            ...params.data,\n            thumbnail: {\n              ...transformedNewThumbnail,\n              ...formerThumbnail\n            }\n          }\n        })\n      })\n      .catch(err => {\n        return Promise.reject(err);\n      })\n  },\n});\n\n/**\n* Convert a `File` object returned by the upload input into a base 64 string.\n* That's not the most optimized way to store images in production, but it's\n* enough to illustrate the idea of data provider decoration.\n*/\nconst convertFileToBase64 = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = reject;\n\n    reader.readAsDataURL(file.rawFile);\n  });\n}\n\n\nexport default addUploadCapabilities;\n","import { fetchUtils } from 'react-admin';\nimport jsonServerProvider from 'ra-data-json-server';\nimport addUploadFeature from './addUploadFeature';\n\nconst REST_API = process.env.REACT_APP_REST_API_URL;\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) {\n    options.headers = new Headers({ Accept: 'application/json' });\n  }\n  options.headers.set('X-Access-Token', localStorage.getItem('token'));\n  return fetchUtils.fetchJson(url, options);\n};\n\nconst restProvider = jsonServerProvider(REST_API, httpClient);\nconst uploadCapableDataProvider = addUploadFeature(restProvider);\n\nconst delayedDataProvider = new Proxy(uploadCapableDataProvider, {\n  get: (target, name, self) =>\n    name === 'then' // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method\n      ? self\n      : (resource, params) =>\n        new Promise(resolve =>\n          setTimeout(\n            () => resolve(uploadCapableDataProvider[name](resource, params)),\n            500\n          )\n        ),\n});\n\nexport default delayedDataProvider;"],"sourceRoot":""}