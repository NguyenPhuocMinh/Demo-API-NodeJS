{"version":3,"sources":["dataProvider/addUploadFeature.js","dataProvider/rest.js"],"names":["convertFileToBase64","file","Promise","resolve","reject","reader","FileReader","readAsDataURL","rawFile","onload","result","onerror","uploadCapableDataProvider","dataProvider","update","resource","params","data","thumbnail","thumbnailValid","File","arrImages","push","length","arrPromises","map","image","all","then","base64Images","base64ImageUrl","imageUrl","src","title","addUploadFeature","jsonServerProvider","process","url","options","headers","Headers","Accept","set","localStorage","getItem","fetchUtils","fetchJson","delayedDataProvider","Proxy","get","target","name","self","setTimeout"],"mappings":"6IAwDMA,EAAsB,SAAAC,GAAI,OAC9B,IAAIC,SAAQ,SAACC,EAASC,GACpB,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,cAAcN,EAAKO,SAC1BH,EAAOI,OAAS,kBAAMN,EAAQE,EAAOK,SACrCL,EAAOM,QAAUP,MC9CfQ,EDVwB,SAAAC,GAAY,kCACrCA,GADqC,IAExCC,OAAQ,SAACC,EAAUC,GACjB,GAAiB,aAAbD,IAA4BC,EAAOC,KAAKC,UAC1C,OAAOL,EAAaC,OAAOC,EAAUC,GAEvC,IAAMG,EAAiBH,EAAOC,KAAKC,WAAaF,EAAOC,KAAKC,UAAUV,mBAAmBY,KACrFC,EAAY,GAIhB,GAHIF,GACFE,EAAUC,KAAKN,EAAOC,KAAKC,WAEzBG,EAAUE,OAAS,EAAG,CACxB,IAAIC,EAAc,GAClBH,EAAUI,KAAI,SAAAC,GACZF,EAAYF,KAAKtB,EAAoB0B,OAEvC,IAAMT,EAAI,eAAQD,EAAOC,MACzB,OAAOf,QAAQyB,IAAIH,GAChBI,MAAK,SAAAC,GAAY,OAAIA,EAAaJ,KAAI,SAAAK,GACrC,GAAIX,EAAgB,CAClB,IAAMY,EAAW,CACfC,IAAKF,EACLG,MAAO,aAEThB,EAAKC,UAAYa,SAGpBH,MAAK,kBAAMf,EAAaC,OAAOC,EAApB,2BACPC,GADO,IAEVC,aAGJ,IAAMA,EAAI,eAAQD,EAAOC,MACnBc,EAAW,CACfC,IAAKhB,EAAOC,KAAKC,UACjBe,MAAO,aAGT,OADAhB,EAAKC,UAAYa,EACVlB,EAAaC,OAAOC,EAApB,2BACFC,GADE,IAELC,aC9B0BiB,CADbC,YAVJC,aAEE,SAACC,GAAuB,IAAlBC,EAAiB,uDAAP,GAKjC,OAJKA,EAAQC,UACXD,EAAQC,QAAU,IAAIC,QAAQ,CAAEC,OAAQ,sBAE1CH,EAAQC,QAAQG,IAAI,iBAAkBC,aAAaC,QAAQ,UACpDC,IAAWC,UAAUT,EAAKC,OAM7BS,EAAsB,IAAIC,MAAMpC,EAA2B,CAC/DqC,IAAK,SAACC,EAAQC,EAAMC,GAAf,MACM,SAATD,EACIC,EACA,SAACrC,EAAUC,GAAX,OACA,IAAId,SAAQ,SAAAC,GAAO,OACjBkD,YACE,kBAAMlD,EAAQS,EAA0BuC,GAAMpC,EAAUC,MACxD,YAKG+B","file":"static/js/4.c799f261.chunk.js","sourcesContent":["/**\n * For posts update only, convert uploaded image in base 64 and attach it to\n * the `picture` sent property, with `src` and `title` attributes.\n */\n\nconst addUploadCapabilities = dataProvider => ({\n  ...dataProvider,\n  update: (resource, params) => {\n    if (resource !== 'accounts' || !params.data.thumbnail) {\n      return dataProvider.update(resource, params);\n    }\n    const thumbnailValid = params.data.thumbnail && params.data.thumbnail.rawFile instanceof File;\n    let arrImages = [];\n    if (thumbnailValid) {\n      arrImages.push(params.data.thumbnail)\n    }\n    if (arrImages.length > 0) {\n      let arrPromises = [];\n      arrImages.map(image => {\n        arrPromises.push(convertFileToBase64(image))\n      })\n      const data = { ...params.data };\n      return Promise.all(arrPromises)\n        .then(base64Images => base64Images.map(base64ImageUrl => {\n          if (thumbnailValid) {\n            const imageUrl = {\n              src: base64ImageUrl,\n              title: 'thumbnail'\n            }\n            data.thumbnail = imageUrl\n          }\n        }))\n        .then(() => dataProvider.update(resource, {\n          ...params,\n          data\n        }))\n    } else {\n      const data = { ...params.data };\n      const imageUrl = {\n        src: params.data.thumbnail,\n        title: 'thumbnail'\n      }\n      data.thumbnail = imageUrl;\n      return dataProvider.update(resource, {\n        ...params,\n        data\n      })\n    }\n  },\n});\n\n/**\n* Convert a `File` object returned by the upload input into a base 64 string.\n* That's not the most optimized way to store images in production, but it's\n* enough to illustrate the idea of data provider decoration.\n*/\nconst convertFileToBase64 = file =>\n  new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file.rawFile);\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = reject;\n  });\n\n\nexport default addUploadCapabilities;\n","import { fetchUtils } from 'react-admin';\nimport jsonServerProvider from 'ra-data-json-server';\nimport addUploadFeature from './addUploadFeature';\n\nconst REST_API = process.env.REACT_APP_REST_API_URL;\n\nconst httpClient = (url, options = {}) => {\n  if (!options.headers) {\n    options.headers = new Headers({ Accept: 'application/json' });\n  }\n  options.headers.set('X-Access-Token', localStorage.getItem('token'));\n  return fetchUtils.fetchJson(url, options);\n};\n\nconst restProvider = jsonServerProvider(REST_API, httpClient);\nconst uploadCapableDataProvider = addUploadFeature(restProvider);\n\nconst delayedDataProvider = new Proxy(uploadCapableDataProvider, {\n  get: (target, name, self) =>\n    name === 'then' // as we await for the dataProvider, JS calls then on it. We must trap that call or else the dataProvider will be called with the then method\n      ? self\n      : (resource, params) =>\n        new Promise(resolve =>\n          setTimeout(\n            () => resolve(uploadCapableDataProvider[name](resource, params)),\n            500\n          )\n        ),\n});\n\nexport default delayedDataProvider;"],"sourceRoot":""}